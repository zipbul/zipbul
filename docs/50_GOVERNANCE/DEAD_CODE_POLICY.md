# DEAD_CODE_POLICY

이 문서는 Zipbul 프로젝트에서 데드 코드/데드 파일을 판단하고 제거하는 정책을 정의한다.

## 목적

- 데드코드를 “언젠가 쓸지도”라는 이유로 방치하는 것을 금지한다.
- 제거 작업의 절차/검증/롤백 기준을 고정해 결정성과 안정성을 지킨다.

## 적용 범위

- 레포 전체(패키지/예제/테스트 포함)

## 목표

- 코드베이스의 결정성, 안정성, 유지보수성을 저해하는 **사용되지 않는 코드/파일**을 지속적으로 제거한다.
- 제거 과정에서 AOT/AST 결정성을 훼손하거나, 숨은 의존성으로 인해 런타임/빌드가 깨지는 상황을 방지한다.

## 용어 정의

- **Dead code**: 현재 제품 기능/테스트/빌드 파이프라인에 의해 **도달/참조/호출되지 않는 코드**.
- **Dead file**: 빌드/테스트/런타임 경로 어디에서도 import/require/참조되지 않는 파일.
- **Accidentally reachable**: 현재는 우연히 도달하지만, 계약/정책상 의존이 금지된 경로에서만 사용되는 코드.

## 비목표 (Non-Goal)

- 본 문서는 특정 정적 분석 도구의 결과를 데드 판정의 정본(SSOT)으로 채택하지 않는다.
- 특히 Knip은 현재 프로젝트의 데드코드/데드파일 판정 기준을 만족시키지 못하므로, 집행/판정에 사용하지 않는다.

## 제거 대상 분류

제거 대상은 아래 3종 중 하나로 분류한다.

1. **Dead code / Dead file**
   - 진입점/공개 API/테스트 엔트리에서 시작하는 참조 그래프에서 도달 불가

2. **Functionally valueless code / file**
   - 논리적으로 도달 가능하지만, 제품/테스트/계약 관점에서 기능적 가치가 0
   - 제거 전후에 관찰 가능한 동작(출력, 상태 변화, 에러, 로그, 메트릭)이 동일하고, 해당 코드가 제공하던 의미가 public contract(문서/Facade/export)로 존재하지 않거나 이미 다른 정본 경로로 대체된 경우를 말한다.
   - 예: no-op(상태/출력/외부 효과에 영향을 주지 않음), 중복 경로, 계약 없는 레거시 shim, 금지된 경로에서만 우연히 도달
   - `Valueless` 판정의 최종 권한자는 사용자(maintainer)이며,
     에이전트는 `Valueless`로 분류 제안만 할 수 있고 단독 확정할 수 없다(MUST NOT).

3. **Placeholder / Tombstone**
   - 삭제 대신 빈 파일, `{}`, `export {}`, no-op 함수, 의미 없는 wrapper, 주석 흔적을 남기는 형태
   - 이는 제거 대상이 아니라 **금지되는 삭제 방식**으로 취급한다.

## 제거 원칙

1. **결정성 우선**
   - 제거는 “되면 좋음”이 아니라 “결정성을 지키기 위한 기본 활동”이다.

2. **범위 밖 정리 금지**
   - 사용자가 요청한 작업 범위를 벗어나서 “겸사겸사 청소”를 하지 않는다.
   - 단, 현재 작업 범위에 포함된 파일/모듈 안에서 발견된 데드코드는 제거 대상이다.

3. **증명 없는 제거 금지**
   - 제거 전에 “왜 데드인지”를 증명해야 한다.
   - 데드 판정의 근거는 PR 설명 또는 변경 로그로 남겨야 한다.

## 증명 기록 포맷 (Enforced)

데드 코드/파일 제거 또는 “유지(예외)” 결정을 PR에 포함한다면, PR 설명(또는 변경 로그)은
아래 항목을 **누락 없이** 포함해야 한다(MUST).

- 대상: 제거/유지 대상 파일/심볼 목록
- 분류: `Dead` / `Valueless` / `Keep (Exception)` 중 1개
- `Keep (Exception)`인 경우, 반드시 예외 요건 4가지(계획/추적/기간/비결정성 비의존)를 각각 명시해야 한다(MUST).
- 근거(Proof): 아래 항목 중 해당 분류의 최소 요건을 만족하는 근거 목록
- 영향(Impact): 관찰 가능한 동작(출력/상태 변화/에러/로그/메트릭) 변화 여부
- 검증(Verification): 최소 `verify` 통과 여부 및 범위

증명 항목은 “느낌/추정”이 아니라 재현 가능한 근거여야 한다(MUST).

## Public API 판정 및 에이전트 절차 (Enforced)

이 레포에서 public API는 패키지 루트 `index.ts`(Public Facade)로만 정의한다(MUST).

- 패키지 루트 `index.ts`에서 export 되는 심볼 목록이 해당 패키지의 public API 후보 목록이다(MUST).
- 어떤 심볼이 “실제로 노출되는 public API인지”의 최종 판단은 사용자에게 있다(MUST).

에이전트 절차(강제):

- 에이전트가 패키지 루트 `index.ts`를 수정해야 하는 상황이면, 먼저 해당 파일의 export 대상 목록을 나열해야 한다(MUST).
- 에이전트는 사용자가 “노출 대상(유지/추가/삭제)”을 선택·승인하기 전까지, `index.ts`를 수정해서는 안 된다(MUST NOT).
- 사용자가 public API가 아니라고 명시한 심볼은, 다른 사용처가 없다면 dead로 판정해 제거해야 한다(MUST).

## 강제 규칙 (Hard Rules)

- 삭제 대상은 파일/심볼을 완전히 제거한다.
- 삭제를 대신해 빈 파일, `{}`, `export {}`, no-op 함수, 주석 흔적을 남기는 행위는 금지한다.
- 삭제 사실을 기록하기 위한 주석(“removed”, “deprecated”, “kept for reference” 등)은 금지한다.
- 컴파일/타입체크를 통과시키기 위한 “빈 껍데기 남기기”는 정책 위반이다.
  - 호출/참조를 제거하거나, 예외 절차로 승격한다.

## 데드 판정 기준

아래 중 하나라도 만족하면 데드로 판정할 수 있다.

1. **참조 그래프 기준**
   - 프로젝트의 진입점/공개 API/테스트 엔트리에서 시작하는 import 그래프에서 도달 불가.

2. **공개 API(Facade) 기준**
   - 패키지 Public Facade(루트 `index.ts`)를 통해 외부에서 접근할 수 없고,
   - 패키지 내부에서도 도달 불가이며,
   - 향후 계획/명시된 계약에도 포함되지 않는다.

3. **비결정적/금지된 경로에만 의존**
   - 런타임 스캔/동적 import/반사 같은 금지된 패턴에만 기대어 “언젠가 쓰일 수 있음” 형태로 남아 있는 코드.

## 증명 요건 상세 (Proof Criteria)

제거는 “느낌”이 아니라 관찰 가능한 근거로 정당화해야 한다.

### Dead code / Dead file

아래 중 최소 2개 이상의 근거를 확보한다.

- 진입점/공개 API/테스트 엔트리에서 시작하는 참조 그래프에서 도달 불가
- 레포 검색에서 참조 없음
- verify 통과
- AOT 파이프라인이 존재한다면 AOT 결과의 결정성 유지

### Functionally valueless code / file

아래 근거를 모두 확보한다.

- 제거 전후의 관찰 가능한 동작이 동일함을 설명할 수 있다.
- 관찰 가능한 동작에는 출력, 상태 변화, 에러, 로그, 메트릭이 포함된다.
- 해당 코드가 제공하던 의미가 있다면, 대체 위치가 계약으로 존재한다.
- verify 통과
- `Valueless` 제거는 사용자(maintainer)의 명시적 승인 없이 수행할 수 없다(MUST NOT).

## 제거 절차(필수)

1. **대상 식별**
   - import 그래프/사용처 검색/테스트 커버리지/번들 결과 등을 통해 후보를 식별한다.

2. **사용처 증명**
   - 후보 심볼/파일에 대해 “실사용 경로가 없다”는 증거를 확보한다.

3. **근거 기록**
   - 제거 분류(Dead/Valueless)와 증명 근거를 PR 설명 또는 변경 로그로 남긴다.

4. **안전한 제거**
   - 제거는 가능한 한 **작은 단위**로 수행한다.
   - 순수 리네임/이동/포맷팅과 섞지 않는다.
   - 삭제는 파일/심볼의 완전 제거로만 수행한다.

5. **검증**
   - 최소 기준: `verify`가 통과해야 한다.
   - AOT 파이프라인이 존재한다면 AOT 결과의 결정성이 유지되어야 한다.
   - `verify`의 정확한 구성(스크립트/명령)은 [VERIFY.md](../40_ENGINEERING/VERIFY.md)에 의해 정의된다.
   - 본 레포에서 AOT 파이프라인의 “존재 여부”는 `verify`에 포함된 공식 검증 단계로 판정한다.
     (즉, `verify`에 AOT 검증이 포함되어 있다면 AOT는 “존재”하는 것으로 간주한다.)

6. **롤백 기준**
   - 제거 후 테스트/빌드/AOT에 영향이 있으면 즉시 롤백하고 원인 분석으로 전환한다.

## 예외(허용 조건)

다음의 경우에 한해 “현재는 도달하지 않지만 유지”가 허용될 수 있다.

- **명시된 마이그레이션/플래그 계획**이 있고,
- 해당 계획이 문서(예: PLAN/ROADMAP/ISSUE)에 의해 추적 가능하며,
- 유지 기간과 제거 시점이 문서 또는 이슈로 명시되어 있고,
- 코드가 비결정적 런타임 스캔/반사에 의존하지 않는다.

## 금지

- “나중에 쓸지도 몰라서”를 이유로 데드코드를 남기는 행위
- 데드코드 제거를 핑계로 범위 밖 리팩토링을 같이 하는 행위
- 제거 작업에서 동적 의존성/런타임 스캔을 새로 도입하는 행위
